---
title: n00bzCTF
time: 2024-08-05 12:00:00
categories: [CTF, WriteUps]
tags: [CTF, WriteUps]
image: /assets/posts/n00bzCTF/0.png
---

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


Well, this was a blessing in disguise as it was made made for n00bz by n00bz.

```bash
Authors: AbuCTF, MrRobot, SHL, PattuSai
```

## Cryptography

### RSA

The cryptography category is incomplete without RSA. So here is a simple RSA challenge. Have fun! Author: `noob_abhinav`

**Attachments**

- [encryption.txt](https://static.n00bzunit3d.xyz/Crypto/RSA/encryption.txt)

Ah, the OG RSA challenge. 

```bash
e = 3
n = 135112325288715136727832177735512070625083219670480717841817583343851445454356579794543601926517886432778754079508684454122465776544049537510760149616899986522216930847357907483054348419798542025184280105958211364798924985051999921354369017984140216806642244876998054533895072842602131552047667500910960834243
c = 13037717184940851534440408074902031173938827302834506159512256813794613267487160058287930781080450199371859916605839773796744179698270340378901298046506802163106509143441799583051647999737073025726173300915916758770511497524353491642840238968166849681827669150543335788616727518429916536945395813
```

This is a straight forward challenge, of course you can take these values and paste it in any RSA decoders like `dcode` or `RsaCtfTool` and it would work. But letâ€™s study the theory behind the reason that weâ€™re able to crack the cipher. 

> Donâ€™t Rush The Process, Trust The Process.
> 

Hereâ€™s an example with the `RsaCtfTool`.

```bash
â””â”€$ python3 RsaCtfTool.py -n 135112325288715136727832177735512070625083219670480717841817583343851445454356579794543601926517886432778754079508684454122465776544049537510760149616899986522216930847357907483054348419798542025184280105958211364798924985051999921354369017984140216806642244876998054533895072842602131552047667500910960834243 
-e 3 --decrypt 13037717184940851534440408074902031173938827302834506159512256813794613267487160058287930781080450199371859916605839773796744179698270340378901298046506802163106509143441799583051647999737073025726173300915916758770511497524353491642840238968166849681827669150543335788616727518429916536945395813

Decrypted data :
HEX : 0x6e3030627a7b6372797074305f31735f316e63306d706c3374335f773174683075745f72733421217d
INT (big endian) : 235360648501923597413504426673122110620436456645077837051697081536135487875222175025616363200782717
INT (little endian) : 267274803801739728615674650006248742190143184448285803664400617962080516309180649444183969553723502
utf-8 : n00bz{crypt0_1s_1nc0mpl3t3_w1th0ut_rs4!!}
STR : b'n00bz{crypt0_1s_1nc0mpl3t3_w1th0ut_rs4!!}'
```

Note: I deep dive into theoretical mathematics and cryptography. If you good, skip to the next challenge.

Okay, this challenge involves the vulnerability in the exponent being a small number. We call this the *small public exponent attack*.

In RSA encryption, the security comes from the difficulty of reversing the encryption process without the private key. The process is based on modular arithmetic, where a message m is raised to the power of an exponent e and then reduced modulo n. The encryption formula is:

$$
c=m^emodn
$$

Here, c is the ciphertext, e is the public exponent, and n is the modulus, which is a product of two large prime numbers.

When e is small, like e = 3 , and the message m is also small, something unusual can happen.

This is because, In typical RSA encryption, m^e should be much larger than n, so that the operation m^emodn effectively "`wraps around`" [Iâ€™ll come back on what wraps around really means] and gives a number within the range of 0 to n -1. This wrapping ensures that the original message $m$ cannot be easily derived from the ciphertext c.

However, if the message m is small, then m^e might still be smaller than . For example, if m is small and e =3, then:

$$
m^3 < n
$$

In this case, the operation m^3 modn does nothing because m^e is already smaller than n. Therefore, the ciphertext c will just be m^e without any reduction. So, we can write:

$$
c = m^3
$$

So if an attacker intercepts this ciphertext c , they can easily recover the original message m by taking the cube root of c :

$$
m = \sqrt[3]{c}
$$

This works because the ciphertext is just m^e, and taking the cube root of m^e gives back m. No special mathematical tricks or complex calculations are neededâ€”just a simple cube root operation.

<aside>
ðŸ’¡ The term "wraps around" refers to how modular arithmetic works. When we compute m^emodn, we are essentially reducing the number m^e to fit within the range from 0 to n -1.

</aside>

But funnily, there is a unique case for this, even thought what happens when m^e equals to n, Iâ€™ll leave this as an exercise for the reader to think about LOL.

![1](../assets/posts/n00bzCTF/1.jpg)

`Exploit Time`

```python
import gmpy2

e = 3
n = 135112325288715136727832177735512070625083219670480717841817583343851445454356579794543601926517886432778754079508684454122465776544049537510760149616899986522216930847357907483054348419798542025184280105958211364798924985051999921354369017984140216806642244876998054533895072842602131552047667500910960834243
c = 13037717184940851534440408074902031173938827302834506159512256813794613267487160058287930781080450199371859916605839773796744179698270340378901298046506802163106509143441799583051647999737073025726173300915916758770511497524353491642840238968166849681827669150543335788616727518429916536945395813

m = gmpy2.iroot(c, e)[0]
mInt = int(m)

mBytes = mInt.to_bytes((mInt.bit_length() + 7) // 8, byteorder='big')
flag = mBytes.decode('utf-8')

print("Flag:", flag)
```

Output:

```python
â””â”€$ python3 solve.py
Flag: n00bz{crypt0_1s_1nc0mpl3t3_w1th0ut_rs4!!}
```

Flag: `n00bz{crypt0_1s_1nc0mpl3t3_w1th0ut_rs4!!}`

### **Vinegar**

Can you decode this message? Note: Wrap the decrypted text in n00bz{}. Author: `noob_abhinav`

**Attachments**

- [enc.txt](https://static.n00bzunit3d.xyz/Crypto/Vinegar/enc.txt)

```python
Encrypted flag: nmivrxbiaatjvvbcjsf
Key: secretkey
```

Weâ€™ve been given the ciphertext and key, and this totally points to **`Vigenere` Cipher.**

<img src="/assets/posts/n00bzCTF/2.png" alt="p4" width="60%"/>

Head on to `dCode` to decode it.

![3](../assets/posts/n00bzCTF/3.png)

Flag: `n00bz{vigenerecipherisfun}`

### **Vinegar 2**

Never limit yourself to only alphabets! Author: `NoobMaster`

**Attachments**

- [chall.py](https://static.n00bzunit3d.xyz/Crypto/Vinegar2/chall.py)
- [enc.txt](https://static.n00bzunit3d.xyz/Crypto/Vinegar2/enc.txt)

```python
alphanumerical = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*(){}_?'
matrix = []
for i in alphanumerical:
        matrix.append([i])

idx=0
for i in alphanumerical:
        matrix[idx][0] = (alphanumerical[idx:len(alphanumerical)]+alphanumerical[0:idx])
        idx += 1

flag=open('../src/flag.txt').read().strip()
key='5up3r_s3cr3t_k3y_f0r_1337h4x0rs_r1gh7?'
assert len(key)==len(flag)
flag_arr = []
key_arr = []
enc_arr=[]
for y in flag:
        for i in range(len(alphanumerical)):
                if matrix[i][0][0]==y:
                        flag_arr.append(i)

for y in key:
        for i in range(len(alphanumerical)):
                if matrix[i][0][0]==y:
                        key_arr.append(i)

for i in range(len(flag)):
        enc_arr.append(matrix[flag_arr[i]][0][key_arr[i]])
encrypted=''.join(enc_arr)
f = open('enc.txt','w')
f.write(encrypted)
```

```python
â””â”€$ cat enc.txt
*fa4Q(}$ryHGswGPYhOC{C{1)&_vOpHpc2r0({
```

So, weâ€™ve been given an another implementation of the **`Vigenere` Cipher.** But this time around `dCode` or `CyberChef` wonâ€™t be able to decode it since we have a much larger character set and hence the matrix is alphanumeric  when compared to the traditional alphabetic matrices that `dCode` uses. 

Another thing to note is that the key is the same length of the ciphertext and it includes special characters and all of that.

Key:      `5up3r_s3cr3t_k3y_f0r_1337h4x0rs_r1gh7?`

Cipher: `*fa4Q(}$ryHGswGPYhOC{C{1)&_vOpHpc2r0({`

- For each character in the flag and key, the code finds the index of that character in the `alphanumerical` string. This index is stored in `flag_arr` and `key_arr`.
- **Encryption:**
    - The encryption is performed by iterating over each character in the flag and key simultaneously. For each character in the flag, the code finds the corresponding row in the matrix using `flag_arr` (the index of the flag character).
    - Then, it uses the corresponding index from `key_arr` to find the character in that row, which becomes part of the encrypted message.
    - The resulting encrypted message is stored in `enc.txt`.

Now, we write a script that reverses the encryption by using the key to map the encrypted characters back to the original characters in the flag.

```python
alphanumerical = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*(){}_?'
matrix = []

for i in alphanumerical:
    matrix.append([i])

for idx, i in enumerate(alphanumerical):
    matrix[idx][0] = (alphanumerical[idx:] + alphanumerical[:idx])

cipher = '*fa4Q(}$ryHGswGPYhOC{C{1)&_vOpHpc2r0({'
key = '5up3r_s3cr3t_k3y_f0r_1337h4x0rs_r1gh7?'

keyIndices = []
for y in key:
    for i in range(len(alphanumerical)):
        if matrix[i][0][0] == y:
            keyIndices.append(i)

decrypted = []
for i, encChar in enumerate(cipher):
    keyIDX = keyIndices[i]
    for j, char in enumerate(matrix[keyIDX][0]):
        if char == encChar:
            decrypted.append(alphanumerical[j])
            break

flag = ''.join(decrypted)
print(flag)
```

Flag: `n00bz{4lph4num3r1c4l_1s_n0t_4_pr0bl3m}`

### Random

I hid my password behind an impressive sorting machine. The machine is very luck based, orÂ **is it**?!?!?!? Author: Connor Chang

**Attachments:**

- [server.cpp](https://static.n00bzunit3d.xyz/Crypto/Random/server.cpp)

```cpp
#include<chrono>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<string>
#include<fstream>
#include<thread>
#include<map>
using namespace std;

bool amazingcustomsortingalgorithm(string s) {
    int n = s.size();
    for (int i = 0; i < 69; i++) {
        cout << s << endl;
        bool good = true;
        for (int i = 0; i < n - 1; i++)
            good &= s[i] <= s[i + 1];

        if (good)
            return true;

        random_shuffle(s.begin(), s.end());

        this_thread::sleep_for(chrono::milliseconds(500));
    }

    return false;
}

int main() {
    string s;
    getline(cin, s);

    map<char, int> counts;
    for (char c : s) {
        if (counts[c]) {
            cout << "no repeating letters allowed passed this machine" << endl;
            return 1;
        }
        counts[c]++;
    }

    if (s.size() < 10) {
        cout << "this machine will only process worthy strings" << endl;
        return 1;
    }

    if (s.size() == 69) {
        cout << "a very worthy string" << endl;
        cout << "i'll give you a clue'" << endl;
        cout << "just because something says it's random mean it actually is" << endl;
        return 69;
    }

    random_shuffle(s.begin(), s.end());

    if (amazingcustomsortingalgorithm(s)) {
        ifstream fin("flag.txt");
        string flag;
        fin >> flag;
        cout << flag << endl;
    }
    else {
        cout << "UNWORTHY USER DETECTED" << endl;
    }
}
```

<img src="/assets/posts/n00bzCTF/4.png" alt="p4" width="40%"/>

```cpp
â””â”€$ nc challs.n00bzunit3d.xyz 10208
4761058239
0123456789
n00bz{5up3r_dup3r_ultr4_54f3_p455w0rd_1fa89f63a437}
```

Flag: `n00bz{5up3r_dup3r_ultr4_54f3_p455w0rd_1fa89f63a437}`
